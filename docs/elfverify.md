# elfverify - 可执行文件验证工具

## 简介

`elfverify` 是一个基于 eBPF 技术的可执行文件验证工具，能够根据白名单策略防止来自不受信任来源的应用程序执行。该工具通过拦截文件执行和内存映射操作，实现对可执行文件和脚本的访问控制，有效防止恶意程序的执行。

## 主要功能

- **可执行文件控制**：基于 eBPF LSM（Linux Security Module）钩子，实时监控和控制程序执行
- **白名单机制**：采用白名单策略，只允许受信任的程序执行
- **多种执行方式拦截**：支持对二进制文件和脚本文件的执行控制
- **用户和路径双重验证**：支持基于用户身份和文件路径的访问控制
- **递归目录保护**：支持对目录及其子目录的递归保护
- **执行日志记录**：记录所有被拦截的程序执行尝试

## 编译构建

在项目根目录下执行：

```bash
make policy/elfverify
```

## 使用方法

### 基本语法

```bash
./elfverify [选项]
```

### 命令行选项

- `-p, --policy-file <策略文件>`：指定策略文件路径（默认：elfverify.pol）
- `-h, --help`：显示帮助信息

### 示例

```bash
# 使用默认策略文件 elfverify.pol
sudo ./elfverify

# 指定自定义策略文件
sudo ./elfverify -p /path/to/custom.pol

# 显示帮助信息
./elfverify -h
```

## 策略文件格式

策略文件采用简单的键值对格式，每行定义一条白名单规则。

### 基本语法

```
<类型>=<内容>
```

### 规则类型

#### 用户规则（user）
允许指定用户执行任意程序。

```
user=<用户名>
```

#### 路径规则（path）
允许指定路径下的程序被执行。

```
path=<文件或目录路径>
```

### 策略文件示例

```bash
# 允许 root 用户执行任意程序
user=root

# 允许系统标准可执行文件目录
path=/usr/bin
path=/bin
path=/usr/local/bin

# 允许系统库目录（动态链接库）
path=/usr/lib
path=/usr/libexec

# 允许特定应用程序
path=/opt/myapp/bin/myapp

# 注释行以 # 开头
# 这是一条注释
```

### 规则说明

1. **用户规则**：当匹配到用户规则时，该用户可以执行任意程序
2. **路径规则**：
   - 如果指定的是文件，则只允许执行该文件
   - 如果指定的是目录，则递归允许该目录及子目录下的所有文件执行
3. **白名单逻辑**：只有在白名单中的用户或路径才被允许执行，其他都被拒绝

## 工作原理

### eBPF 程序架构

`elfverify` 工具由两部分组成：

1. **用户空间程序**（elfverify.cpp）：
   - 解析命令行参数和策略文件
   - 加载和管理 eBPF 程序
   - 处理执行日志输出

2. **内核空间 eBPF 程序**（elfverify.bpf.c）：
   - 挂载到 LSM 钩子点
   - 实时拦截程序执行和内存映射
   - 执行白名单验证逻辑

### LSM 钩子点

工具挂载到以下 LSM 钩子点：

- `mmap_file`：内存映射文件操作（用于检测可执行文件加载）
- `bprm_creds_for_exec`：程序执行凭证检查
- `bprm_check_security`：程序执行安全检查

### 验证逻辑

1. **文件验证**：检查要执行的文件是否在白名单路径中
2. **父目录验证**：检查文件的父目录是否在白名单路径中
3. **用户验证**：检查当前用户是否在白名单用户中
4. **二进制和脚本区分**：区分处理二进制文件和脚本文件的执行

### 数据结构

#### BPF Maps

- `whitelist`：存储白名单规则的哈希表（最大 400,000 条规则）
- `logs`：环形缓冲区，用于记录执行日志

## 运行环境要求

- Linux 内核版本 ≥ 5.8（支持 BPF LSM）
- 启用 BPF LSM 支持的内核配置
- 需要 root 权限运行

## 日志输出

当有程序执行被拦截时，工具会输出如下格式的日志：

```
process <进程ID> of user <用户ID> tried to execve <文件类型> file (dev: <设备>, ino: <inode>), denied!
```

示例：
```
process 12345 of user 1000 tried to execve binary file (dev: 801, ino: 123456), denied!
process 67890 of user 1000 tried to execve script file (dev: 801, ino: 789012), denied!
```

### 日志字段说明

- **进程ID**：尝试执行程序的进程标识符
- **用户ID**：执行用户的用户标识符
- **文件类型**：
  - `binary`：二进制可执行文件
  - `script`：脚本文件
- **设备和inode**：文件的设备号和inode号，用于唯一标识文件

## 安全模型

### 白名单策略

`elfverify` 采用"默认拒绝，显式允许"的安全模型：

1. **默认行为**：拒绝所有程序执行
2. **显式允许**：只有在策略文件中明确指定的用户或路径才被允许
3. **递归保护**：目录规则会递归应用到所有子目录和文件

### 双重验证机制

程序执行需要满足以下条件之一：

1. **用户白名单**：当前用户在用户白名单中
2. **路径白名单**：可执行文件或其父目录在路径白名单中

## 使用场景

- **系统安全加固**：防止恶意程序在系统中执行
- **恶意软件防护**：作为反恶意软件解决方案的一部分
- **应用程序白名单**：在高安全环境中实施应用程序白名单策略
- **容器安全**：在容器环境中限制可执行程序
- **合规性要求**：满足特定行业的程序执行控制要求

## 配置最佳实践

### 基础系统配置

```bash
# 系统关键用户
user=root

# 系统可执行文件目录
path=/bin
path=/sbin
path=/usr/bin
path=/usr/sbin
path=/usr/local/bin
path=/usr/local/sbin

# 系统库目录
path=/lib
path=/lib64
path=/usr/lib
path=/usr/lib64
path=/usr/libexec

# Python 解释器和模块
path=/usr/lib/python3.9
path=/usr/lib/python3.8

# 其他必要目录
path=/etc/alternatives
```

### 应用程序配置

```bash
# 特定应用程序
path=/opt/myapp
path=/home/user/apps/trusted_app

# 开发工具（如需要）
path=/usr/share/code
path=/opt/idea
```

## 注意事项

1. **权限要求**：必须以 root 权限运行
2. **内核支持**：确保内核支持 BPF LSM 功能
3. **策略文件格式**：确保策略文件格式正确，错误的规则会被跳过
4. **性能影响**：大量规则可能会影响程序启动性能
5. **系统兼容性**：可能会影响某些依赖动态加载的应用程序
6. **文件存在性**：策略文件中指定的路径必须存在

## 故障排除

### 常见问题

1. **程序无法执行**：
   - 检查程序路径是否在白名单中
   - 确认当前用户是否有执行权限
   - 验证策略文件配置

2. **BPF 程序加载失败**：
   - 检查内核是否支持 BPF LSM
   - 确认以 root 权限运行

3. **策略规则不生效**：
   - 检查策略文件语法
   - 验证路径是否存在
   - 查看程序日志输出
